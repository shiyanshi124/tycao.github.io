

TCP 为什么是三次握手，为什么不是两次或四次 :question: :question: 
===========
!["hh1"](https://github.com/tycao/tycao.github.io/blob/master/src_tcp/hh1.jpg "hh1")<br />
!["hh2"](https://github.com/tycao/tycao.github.io/blob/master/src_tcp/hh2.jpg "hh2")<br />
!["hh3"](https://github.com/tycao/tycao.github.io/blob/master/src_tcp/hh3.jpg "hh3")<br />

OK，下面正经地来回答下这个问题，要搞清楚这个问题，首先得了解TCP究竟是如何保证可靠传输的。

## TCP三次握手
!["tcp_3"](https://github.com/tycao/tycao.github.io/blob/master/src_tcp/tcp_3.jpg "tcp_3")<br />

PS：TCP协议中，主动发起请求的一端称为**客户端**，被动连接的一端称为**服务端**。不管是客户端还是服务端，TCP连接建立完后都能相互发送和接收数据。

:exclamation: **客户端与服务器端的TCP连接是发生在三次握手成功之后**

- 起初，服务器和客户端都为`CLOSED`状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。 
- 服务器创建完TCB后遍进入`LISTEN`状态，此时准备接收客户端发来的连接请求。

### 第一次握手<br />
- 客户端向服务端发送连接请求报文段。该报文段的头部中`SYN=1，ACK=0，seq=x`。请求发送后，客户端便进入`SYN-SENT`状态。
	- PS1：`SYN=1，ACK=0`表示该报文段为连接请求报文。
	- PS2：`x`为本次TCP通信的字节流的初始序号。 <br />
	TCP规定：`SYN=1`的报文段不能有数据部分，但要消耗掉一个序号。
	
### 第二次握手<br />
- 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：`SYN=1，ACK=1，seq=y，ack=x+1`。 <br />
该应答发送完成后便进入`SYN-RCVD`状态。
	- PS1：`SYN=1，ACK=1`表示该报文段为连接同意的应答报文。
	- PS2：`seq=y`表示服务端作为发送者时，发送字节流的初始序号。
	- PS3：`ack=x+1`表示服务端希望下一个数据报发送序号从x+1开始的字节。

### 第三次握手<br />
当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。 该报文段的头部为：`ACK=1，seq=x+1，ack=y+1`。 客户端发完这个报文段后便进入`ESTABLISHED`状态，服务端收到这个应答后也进入`ESTABLISHED`状态，此时连接的建立完成！


### 为什么连接建立需要三次握手，而不是两次握手？ 
防止失效的连接请求报文段被服务端接收，从而产生错误。<br />

PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。<br />

若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入`ESTABLISHED`状态，而服务端在收到连接请求后就进入`ESTABLISHED`状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。<br />

## TCP四次挥手
!["tcp_say_goodbye"](https://github.com/tycao/tycao.github.io/blob/master/src_tcp/tcp_say_goodbye.jpg "tcp_say_goodbye")<br />
- TCP连接的释放一共需要四步，因此称为『四次挥手』。 
- 我们知道，TCP连接是双向的，因此在四次挥手中，**前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。**

### 第一次挥手 
若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：` FIN=1，seq=u`。此时，A将进入FIN-WAIT-1状态。
- PS1：FIN=1表示该报文段是一个连接释放请求。
- PS2：seq=u，u-1是A向B发送的最后一个字节的序号。

### 第二次挥手 
B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含： `ACK=1，seq=v，ack=u+1`。
- PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答。
- PS2：seq=v，v-1是B向A发送的最后一个字节的序号。
- PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节。

A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。<br />
第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。

### 第三次挥手 
当B向A发完所有数据后，向A发送连接释放请求，请求头：`FIN=1，ACK=1，seq=w，ack=u+1`。B便进入LAST-ACK状态。

### 第四次挥手 
A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。

### 为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态  :question:
- 为了保证B能收到A的确认应答。 
- 若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭。







*****
作者：大闲人柴毛毛<br />
链接：https://www.zhihu.com/question/24853633/answer/254224088<br />
来源：知乎<br />
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br />
